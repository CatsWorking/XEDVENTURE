<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Terraria-Inspired JS Game</title>
<style>
body,html{margin:0;padding:0;overflow:hidden;background:#6ec5ff;font-family:sans-serif}
canvas{display:block;background:#6ec5ff}
#tip{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);
     background:rgba(0,0,0,0.5);color:#fff;padding:6px 10px;border-radius:8px;
     font-size:14px;opacity:0;transition:opacity 1s;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="tip">Use A/D to move, Space to jump, Left Click to mine, Right Click to place</div>

<script>
// === CONSTANTS ===
const TILE=16;
const W=window.innerWidth,H=window.innerHeight;
const GRAVITY=1800;
const MAX_FALL_SPEED=800;
const JUMP_VELOCITY=-600;
const MAX_REACH=6; // max tile reach for mining/building

// === CANVAS ===
const c=document.getElementById('game');
c.width=W;c.height=H;
const ctx=c.getContext('2d');

// === SIMPLE PERLIN SETUP ===
const PERM=new Uint8Array(512);
for(let i=0;i<256;i++)PERM[i]=i;
for(let i=0;i<256;i++){const j=Math.random()*256|0;[PERM[i],PERM[j]]=[PERM[j],PERM[i]];}
for(let i=0;i<256;i++)PERM[i+256]=PERM[i];
const fade=t=>t*t*t*(t*(t*6-15)+10);
const lerp=(a,b,t)=>a+(b-a)*t;
function grad2(hash,x,y){return ((hash&1)?-x:x)+((hash&2)?-y:y);}
function perlin2D(x,y){
  const xi=Math.floor(x)&255,yi=Math.floor(y)&255;
  const xf=x-Math.floor(x),yf=y-Math.floor(y);
  const a=PERM[xi]+yi,b=PERM[xi+1]+yi;
  const u=fade(xf),v=fade(yf);
  return lerp(
    lerp(grad2(PERM[a],xf,yf),grad2(PERM[b],xf-1,yf),u),
    lerp(grad2(PERM[a+1],xf,yf-1),grad2(PERM[b+1],xf-1,yf-1),u),
    v
  );
}

// === WORLD GEN ===
const chunkSize=16;
const chunkCache=new Map();

function octaveNoise(x,octaves,persistence,scale){
  let total=0,freq=1,amp=1,max=0;
  for(let i=0;i<octaves;i++){
    total+=perlin2D(x*scale*freq,0)*amp;
    max+=amp;
    amp*=persistence;freq*=2;
  }
  return total/max;
}

function genChunk(cx){
  const key=cx;
  if(chunkCache.has(key))return chunkCache.get(key);
  const tiles=[];
  const baseHeight=20;
  for(let tx=0;tx<chunkSize;tx++){
    const wx=cx*chunkSize+tx;
    const n=octaveNoise(wx,3,0.5,0.05);
    const height=Math.floor(baseHeight+n*5);
    tiles[tx]=[];
    for(let y=0;y<80;y++){
      if(y<height){
        let type='stone';
        if(y>=height-1)type='grass';
        else if(y>=height-4)type='dirt';
        tiles[tx][y]=type;
      }else{
        const cave=perlin2D(wx*0.15,y*0.25);
        if(cave>0.25&&y>5)tiles[tx][y]=null;
        else tiles[tx][y]=null;
      }
    }
  }
  chunkCache.set(key,{tiles});
  return {tiles};
}

function getChunk(x){return genChunk(Math.floor(x/chunkSize));}
function getTile(x,y){
  const chunk=getChunk(x);
  const tx=((x%chunkSize)+chunkSize)%chunkSize;
  return chunk.tiles[tx]?.[y];
}
function setTile(x,y,type){
  const chunk=getChunk(x);
  const tx=((x%chunkSize)+chunkSize)%chunkSize;
  if(chunk.tiles[tx])chunk.tiles[tx][y]=type;
}
function getHeightAtWorldX(wx){
  const chunk=getChunk(wx);
  const tx=((wx%chunkSize)+chunkSize)%chunkSize;
  const tiles=chunk.tiles[tx];
  for(let y=tiles.length-1;y>=0;y--)if(tiles[y])return y;
  return 0;
}

// === PLAYER ===
const player={x:0,y:0,vx:0,vy:0,w:14,h:28,onGround:false};
function spawnPlayerAt(x){
  const y=safeSpawnY(x);
  player.x=x*TILE;
  player.y=y*TILE;
  player.vx=player.vy=0;
}
function safeSpawnY(worldX){
  let y=getHeightAtWorldX(worldX);
  while(getTile(worldX,y+1))y++;
  return y+2;
}

// === CAMERA ===
let cameraX=0,cameraY=0;
function updateCamera(){
  const targetX=player.x;
  const targetY=player.y-100;
  const smooth=0.1;
  cameraX+=(targetX-cameraX)*smooth;
  cameraY+=(targetY-cameraY)*smooth;
}

// === INPUT ===
const keys={};
onkeydown=e=>keys[e.key]=true;
onkeyup=e=>keys[e.key]=false;

// === MAIN LOOP ===
let last=0;
function step(ts){
  const dt=(ts-last)/1000;last=ts;
  update(dt);
  draw();
  requestAnimationFrame(step);
}

function update(dt){
  // Move
  if(keys['a'])player.vx=-120;
  else if(keys['d'])player.vx=120;
  else player.vx*=0.8;

  // Jump
  if(keys[' ']&&player.onGround){player.vy=JUMP_VELOCITY;player.onGround=false;}

  // Gravity
  player.vy=Math.min(player.vy+GRAVITY*dt,MAX_FALL_SPEED);
  player.x+=player.vx*dt;
  player.y+=player.vy*dt;

  // Collision (simple)
  const footY=Math.floor(player.y/TILE);
  const midX=Math.floor(player.x/TILE);
  const under=getTile(midX,footY-2);
  if(under){player.y=(footY-1)*TILE;player.vy=0;player.onGround=true;}
  else player.onGround=false;

  updateCamera();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  const startX=Math.floor((cameraX-W/2)/TILE)-1;
  const endX=Math.floor((cameraX+W/2)/TILE)+1;
  for(let x=startX;x<=endX;x++){
    const chunk=getChunk(x);
    const tx=((x%chunkSize)+chunkSize)%chunkSize;
    for(let y=0;y<chunk.tiles[tx].length;y++){
      const t=chunk.tiles[tx][y];
      if(!t)continue;
      let col='#777';
      if(t==='grass')col='#5f8d3e';
      else if(t==='dirt')col='#8b5a3c';
      const sx=(x*TILE-cameraX)+W/2;
      const sy=H/2-(y*TILE-cameraY);
      ctx.fillStyle=col;
      ctx.fillRect(sx,sy,TILE,TILE);
    }
  }

  // Draw player
  ctx.fillStyle='#f5d142';
  const px=W/2-7;
  const py=H/2-(player.y-cameraY)-28;
  ctx.fillRect(px,py,player.w,player.h);
}

// === INIT ===
spawnPlayerAt(200);
requestAnimationFrame(step);

// === Tip ===
const tip=document.getElementById('tip');
setTimeout(()=>{tip.style.opacity=1;setTimeout(()=>{tip.style.opacity=0;},8000);},500);
</script>
</body>
</html>
