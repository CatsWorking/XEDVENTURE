<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Procedural Bean Guy — Grassy Terrain</title>
  <style>
    html,body{height:100%;margin:0;background:#87ceeb;}
    canvas{display:block;margin:0 auto;background:linear-gradient(#87ceeb 0%, #9fd9ff 60%, #6fc7a9 100%);} 
    #ui{position:fixed;left:8px;top:8px;background:rgba(255,255,255,0.8);padding:8px;border-radius:6px;font-family:sans-serif}
    #tip{position:fixed;bottom:8px;left:50%;transform:translateX(-50%);
         background:rgba(255,255,255,0.8);padding:6px 10px;border-radius:6px;
         font-family:sans-serif;font-size:14px;opacity:0;transition:opacity 1.5s ease;}
  </style>
</head>
<body>
  <div id="ui">Controls: A / ← and D / → to move — Space to jump — Hold Shift to run — R to reset movement — Refresh to reset</div>
  <div id="tip">Tip: if Bean-guy is still walking even when movement controls aren’t pressed, click R to reset movement — it should fix it.</div>
  <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const DPR = Math.max(1, window.devicePixelRatio || 1);
let W = 960, H = 600;
function resize(){
  W = Math.min(window.innerWidth, 1280);
  H = Math.min(window.innerHeight, 800);
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);
resize();

const TILE = 32;
const CHUNK_TILES = 20;
const CHUNK_PX = CHUNK_TILES * TILE;
const GROUND_LEVEL = 12;

const player = {
  x: W/2,
  y: 0,
  vx: 0,
  vy: 0,
  w: 22,
  h: 36,
  onGround: false,
  prevVy: 0
};

let cameraX = 0;

const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if(e.key === ' ') e.preventDefault();
  if(e.key === 'r' || e.key === 'R'){
    // Reset movement when R is pressed
    player.vx = 0;
    player.vy = 0;
    keys['a'] = keys['A'] = keys['ArrowLeft'] = false;
    keys['d'] = keys['D'] = keys['ArrowRight'] = false;
    keys[' '] = keys['Spacebar'] = false;
  }
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

function buildPermutation(seed){
  const p = new Uint8Array(512);
  let arr = new Array(256).fill(0).map((_,i)=>i);
  let s = seed | 0;
  for(let i=255;i>0;i--){
    s = (s * 1664525 + 1013904223) | 0;
    const r = Math.abs(s) % (i+1);
    const tmp = arr[i]; arr[i] = arr[r]; arr[r] = tmp;
  }
  for(let i=0;i<512;i++) p[i]=arr[i&255];
  return p;
}
function fade(t){ return t * t * t * (t * (t * 6 - 15) + 10); }
function lerp(a,b,t){ return a + t*(b-a); }
function grad(hash,x){ return ((hash & 1) === 0) ? x : -x; }

const PERM = buildPermutation(123456);
function perlin1D(x){
  const xi = Math.floor(x) & 255;
  const xf = x - Math.floor(x);
  const a = PERM[xi];
  const b = PERM[xi+1];
  const u = fade(xf);
  const g1 = grad(a, xf);
  const g2 = grad(b, xf-1);
  return lerp(g1, g2, u);
}

function octaveNoise(x, octaves=4, persistence=0.5, scale=0.01){
  let total = 0, freq = scale, amp = 1, max = 0;
  for(let i=0;i<octaves;i++){
    total += perlin1D(x * freq) * amp;
    max += amp;
    amp *= persistence;
    freq *= 2;
  }
  return total / max;
}

const chunks = new Map();
function genChunk(xIndex){
  if(chunks.has(xIndex)) return chunks.get(xIndex);
  const heights = new Array(CHUNK_TILES);
  for(let tx=0; tx<CHUNK_TILES; tx++){
    const worldX = (xIndex * CHUNK_TILES + tx);
    const n = octaveNoise(worldX, 5, 0.45, 0.08);
    const tileH = Math.floor(GROUND_LEVEL + n * 4 + Math.sin(worldX*0.15)*1.2);
    heights[tx] = tileH;
  }
  const chunk = {xIndex, heights};
  chunks.set(xIndex, chunk);
  if(chunks.size > 30){
    let farKey = null; let farDist = -1;
    for(const [k,v] of chunks.entries()){
      const dx = Math.abs(k - Math.floor(player.x / CHUNK_PX));
      if(dx > farDist){ farDist = dx; farKey = k; }
    }
    if(farKey !== null) chunks.delete(farKey);
  }
  return chunk;
}

function getHeightAtWorldX(px){
  const worldTileX = Math.floor(px / TILE);
  const xIndex = Math.floor(worldTileX / CHUNK_TILES);
  const chunk = genChunk(xIndex);
  const tx = (worldTileX - xIndex*CHUNK_TILES);
  const tileH = chunk.heights[(tx%CHUNK_TILES+CHUNK_TILES)%CHUNK_TILES];
  return H - tileH * TILE;
}

function drawTerrain(camX){
  const leftWorldX = camX - W/2 - CHUNK_PX;
  const rightWorldX = camX + W/2 + CHUNK_PX;
  const leftTile = Math.floor(leftWorldX / TILE);
  const rightTile = Math.floor(rightWorldX / TILE);
  const leftChunk = Math.floor(leftTile / CHUNK_TILES);
  const rightChunk = Math.floor(rightTile / CHUNK_TILES);

  for(let cx = leftChunk; cx <= rightChunk; cx++){
    const chunk = genChunk(cx);
    for(let tx=0; tx<CHUNK_TILES; tx++){
      const tileH = chunk.heights[tx];
      const worldX = (cx*CHUNK_TILES + tx) * TILE;
      const screenX = Math.round(worldX - camX + W/2);
      const grassY = H - tileH * TILE;
      ctx.fillStyle = '#6bbf4a';
      ctx.fillRect(screenX, grassY, TILE, TILE);
      ctx.fillStyle = '#7b4f3b';
      ctx.fillRect(screenX, grassY + TILE, TILE, (tileH-1)*TILE);
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(screenX, grassY + TILE, TILE, 2);
      ctx.fillStyle = '#4aa23a';
      for(let b=0;b<3;b++){
        const bx = screenX + 4 + b*8;
        const by = grassY + 6 + Math.floor((perlin1D((worldX+b)/50)+1)*4);
        ctx.fillRect(bx, by, 1.5, 6);
      }
    }
  }
}

function drawPlayer(){
  const sx = Math.round(W/2 - player.w/2);
  const sy = Math.round(player.y - player.h);
  ctx.beginPath(); ctx.ellipse(sx + player.w/2, player.y + 6, player.w*0.6, 6, 0, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fill();
  ctx.save();
  ctx.translate(sx + player.w/2, sy + player.h/2);
  ctx.rotate(Math.sin(player.x*0.02 + player.vx*0.1) * 0.08);
  ctx.beginPath();
  ctx.ellipse(0, 0, player.w/2, player.h/2, 0, 0, Math.PI*2);
  ctx.fillStyle = '#ffdd88'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#c88f3a'; ctx.stroke();
  ctx.fillStyle = '#222'; ctx.beginPath(); ctx.ellipse(-5, -6, 3, 3, 0, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(5, -6, 3, 3, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(0, -0, 6, 0.15*Math.PI, 0.85*Math.PI); ctx.lineWidth = 2; ctx.strokeStyle = '#8a4f1c'; ctx.stroke();
  ctx.restore();
}

// Particles
const particles = [];
function spawnParticles(x,y,count,size,speedY){
  for(let i=0;i<count;i++){
    particles.push({
      x: x + (Math.random()-0.5)*10,
      y: y,
      vx: (Math.random()-0.5)*40,
      vy: -Math.random()*speedY,
      life: 0.4 + Math.random()*0.3,
      age: 0,
      size: size * (0.6+Math.random()*0.4)
    });
  }
}

function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx*dt;
    p.y += p.vy*dt;
    p.vy += 400*dt;
    p.age += dt;
    if(p.age > p.life) particles.splice(i,1);
  }
}

function drawParticles(){
  ctx.fillStyle = 'white';
  for(const p of particles){
    ctx.globalAlpha = 1 - (p.age / p.life);
    ctx.beginPath();
    ctx.arc(Math.round(p.x - cameraX + W/2), Math.round(p.y), p.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

const GRAV = 1500;
const MOVE_SPEED = 220;
const RUN_MULT = 1.8;
const JUMP_V = -540;
let last = performance.now();

function update(dt){
  let left = keys['ArrowLeft'] || keys['a'] || keys['A'];
  let right = keys['ArrowRight'] || keys['d'] || keys['D'];
  const run = keys['Shift'] || keys['ShiftLeft'] || keys['ShiftRight'];

  let inputDir = 0;
  if(left) inputDir -= 1;
  if(right) inputDir += 1;

  const speed = MOVE_SPEED * (run ? RUN_MULT : 1);
  const accel = 3000;
  const desiredVx = inputDir * speed;

  if(inputDir === 0){
    const frictionFactor = Math.pow(0.0005, dt);
    player.vx *= frictionFactor;
    if(Math.abs(player.vx) < 0.5) player.vx = 0;
  } else {
    player.vx += Math.sign(desiredVx - player.vx) * Math.min(Math.abs(desiredVx - player.vx), accel * dt);
  }

  if((keys[' '] || keys['Spacebar']) && player.onGround){
    player.vy = JUMP_V;
    player.onGround = false;
    spawnParticles(player.x, player.y, 6, 3, 120);
  }

  player.vy += GRAV * dt;
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  const groundY = getHeightAtWorldX(player.x);
  if(player.y > groundY){
    if(!player.onGround){
      const impact = Math.abs(player.prevVy);
      const count = Math.min(20, Math.max(5, impact/80));
      const size = Math.min(8, Math.max(2, impact/150));
      spawnParticles(player.x, groundY, count, size, impact/4);
    }
    player.y = groundY;
    player.vy = 0;
    player.onGround = true;
  }

  if(player.y < 0) { player.y = 0; player.vy = 0; }
  cameraX = player.x;
  player.prevVy = player.vy;

  if(Math.abs(player.vx) > 20 && player.onGround){
    spawnParticles(player.x, player.y, 1, 2, 30);
  }

  updateParticles(dt);
}

function step(){
  const now = performance.now();
  const dt = Math.min(1/30, (now - last) / 1000);
  last = now;
  update(dt);
  ctx.clearRect(0,0,W,H);
  drawTerrain(cameraX);
  drawHills();
  drawPlayer();
  drawParticles();
  requestAnimationFrame(step);
}

function drawHills(){
  const cam = cameraX;
  for(let layer=0; layer<3; layer++){
    ctx.beginPath();
    const par = 0.2 + layer*0.18;
    const yBase = 120 + layer*40;
    ctx.moveTo(0, H);
    for(let x=0; x<=W; x+=10){
      const worldX = cam*par + x;
      const h = Math.sin(worldX*0.004 + layer) * (30 + layer*20) + yBase;
      ctx.lineTo(x, h);
    }
    ctx.lineTo(W, H);
    ctx.closePath();
    ctx.fillStyle = `rgba(100,160,100,${0.08 + layer*0.06})`;
    ctx.fill();
  }
}

player.x = 0;
player.y = getHeightAtWorldX(player.x);
player.onGround = true;

requestAnimationFrame(step);
canvas.addEventListener('click', ()=> window.focus());

// Fade in the tip, then fade it out after a delay
const tip = document.getElementById('tip');
setTimeout(() => {
  tip.style.opacity = 1; // fade in
  setTimeout(() => {
    tip.style.opacity = 0; // fade out
  }, 8000); // show for 8 seconds
}, 500); // initial delay before showing
</script>
</body>
</html>
